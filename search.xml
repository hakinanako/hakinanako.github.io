<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql-1</title>
      <link href="/2023/01/24/mysql-1/"/>
      <url>/2023/01/24/mysql-1/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-一"><a href="#MySQL-一" class="headerlink" title="MySQL 一"></a>MySQL 一</h1><h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><h2 id="规则规范"><a href="#规则规范" class="headerlink" title="规则规范"></a>规则规范</h2><h3 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h3><p>建议数据库名，表名，表别名，字段名小写</p><p>而关键字，函数名，绑定变量大写</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行注释</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#xxxxx</span><br><span class="line"><span class="comment">-- xxxxx</span></span><br></pre></td></tr></table></figure><p>多行注释</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">xxxxxx</span></span><br><span class="line"><span class="comment">xxxx</span></span><br><span class="line"><span class="comment">xxxxx</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>多行注释的嵌套是没有意义的</p><h3 id="命名"><a href="#命名" class="headerlink" title="*命名"></a>*命名</h3><h2 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h2><h3 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h3><p>sql通用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source 文件的全路径</span><br></pre></td></tr></table></figure><p>方式1在图形化界面下是会报错的，只能在cmd使用</p><p>#注意！#该语句后不接分号；</p><h3 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h3><p>图形化界面</p><p>如SQLyog中，工具-&gt;执行sql脚本-&gt;选择对应文件</p><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><h3 id="基本SELECT"><a href="#基本SELECT" class="headerlink" title="*基本SELECT"></a>*基本SELECT</h3><p>如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span><span class="operator">+</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span><span class="operator">+</span><span class="number">1</span> <span class="keyword">from</span> dual；</span><br></pre></td></tr></table></figure><p>其中dual是伪表</p><h3 id="SELECT-FROM"><a href="#SELECT-FROM" class="headerlink" title="SELECT FROM"></a>SELECT FROM</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> xxx <span class="keyword">from</span> yyy;</span><br></pre></td></tr></table></figure><p>其中xxx是所需查找的字段&#x2F;列，可以使用*号表示查找所有列，结果也就是显示完整的表。</p><p>注意！select语句查询的是列！</p><h2 id="列的别名"><a href="#列的别名" class="headerlink" title="列的别名"></a>列的别名</h2><p>列，也就是字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> employee_id,last_name form employee;</span><br></pre></td></tr></table></figure><p>select后返回的表称为结果集</p><p>共有三种方式起别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> employee_id emp_id,</span><br><span class="line">last_name <span class="keyword">as</span> lastname form employee;</span><br></pre></td></tr></table></figure><p>空格和as语句都是给列起别名的操作，也就是说如此，寻找到employee_id,last_name字段后，结果集的列名将会临时显示成空格或as后的别名</p><p>最好要养成as的好习惯</p><p>实际上as是alias(别名)的简称</p><p>此外还可用“”双引号引起别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> employee_id “emp_id” <span class="keyword">from</span> employee;</span><br></pre></td></tr></table></figure><p>这种方式一般使用在别名是多个单词时，引号还可以提高代码的可读性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> employee_id “emp  id” <span class="keyword">from</span> employee;</span><br></pre></td></tr></table></figure><p>注意！</p><p>别名支持中文(UTF-8标准内)</p><p>在mysql中对于单引号和双引号的区别时不严格的，还是应该尽量遵循规则</p><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><h3 id="基本去重"><a href="#基本去重" class="headerlink" title="基本去重"></a>基本去重</h3><p>select后，重复数据只留一条</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> department_id <span class="keyword">from</span> employees;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> department_id <span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure><p>对于代码1，查询的结果中有大量重复数据</p><p>对于代码2，在1的基础上使用了distinct关键字，作用是去掉重复的数据，对于重复数据结果集中只显示一份</p><h3 id="联合去重"><a href="#联合去重" class="headerlink" title="联合去重"></a>联合去重</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> department_id, salary <span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure><p>这条语句中的distinct对后面两个字段都起作用，也就是返回 department_id相同而salary不同和department_id不同的所有结果，但实际使用的较少。</p><h2 id="空值运算"><a href="#空值运算" class="headerlink" title="空值运算"></a>空值运算</h2><p>空值，也就是null</p><p>首先null不等同于0，而是不存在的意思（Java）</p><p>所有null参与的运算，结果都为null</p><p>ex.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id，salary”月工资“，</span><br><span class="line">salary<span class="operator">*</span>（<span class="number">1</span><span class="operator">+</span>pet）<span class="operator">*</span><span class="number">12</span>”年工资“，pet”奖金“</span><br><span class="line"><span class="keyword">from</span> employee；</span><br></pre></td></tr></table></figure><p>有pet字段表示奖金，其中表中存在无奖金也就是null的行（员工），对于上述运算，则其salary的结果为null，这显然不和常理。对于这种情况会使用if等语句解决（见单行函数）</p><h2 id="着重"><a href="#着重" class="headerlink" title="着重"></a>着重</h2><p>着重号”·“（键盘1左侧）</p><p>当在实际使用时，字段名和关键字等冲突时，就可使用着重号声明该字段不是一个关键字而是字段名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">order</span>；</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ·<span class="keyword">order</span>； </span><br></pre></td></tr></table></figure><h2 id="常数字段"><a href="#常数字段" class="headerlink" title="常数字段"></a>常数字段</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ‘我是’，<span class="number">123</span> department_id <span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure><p>对于这句代码，department_id是存在于表中的，而前面的‘我是’，123这二者是显然不存在的，在返回结果集时，每一行结果前都会加上‘我是’和123这两个字段，这样这二者也被称为常数字段</p><p>注意，这里的‘xx’，单引号引起的是字符串</p><h2 id="显示表结构"><a href="#显示表结构" class="headerlink" title="显示表结构"></a>显示表结构</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">describe</span> employees；</span><br></pre></td></tr></table></figure><p>显示表的完整结构（字段名，字段类型，约束等）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> employees；</span><br></pre></td></tr></table></figure><p>desc是describe的简写，和describe的作用完全相同</p><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>关键字 where</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees；</span><br></pre></td></tr></table></figure><p>该语句得到的是完整的employees表数据。</p><p>使用where，返回符合某一条件的行，如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> department_id <span class="operator">=</span><span class="number">90</span>;</span><br></pre></td></tr></table></figure><p>在全表中查找，返回所有department_id为90的行。</p><p>注意，过滤结构where一定要声明在from后，在where中可以添加丰富的语句</p><h1 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h1><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span>加法</span><br><span class="line"><span class="operator">-</span>减法</span><br><span class="line"><span class="operator">*</span>  乘法</span><br><span class="line"><span class="operator">/</span> 或 DIV除法，其中div是取整，<span class="operator">/</span>为小数</span><br><span class="line"><span class="operator">%</span> 或 MOD求余</span><br></pre></td></tr></table></figure><p>在sql中，注意与java区别，+‘加法符号’没有连接的作用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span><span class="operator">+</span>”<span class="number">1</span>“<span class="operator">=</span><span class="number">1001</span>；<span class="operator">/</span><span class="operator">/</span>java</span><br><span class="line">字符串加法使<span class="type">int</span>自动提升为字符串，连接为长字符串</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span><span class="operator">+</span>‘<span class="number">1</span>’<span class="operator">=</span><span class="number">101</span>；<span class="operator">/</span><span class="operator">/</span><span class="keyword">sql</span></span><br><span class="line"><span class="keyword">sql</span>的加号只有运算的作用，并且引号内会转换为<span class="type">int</span>进行运算</span><br><span class="line">也就是隐式转换</span><br></pre></td></tr></table></figure><p>sql里的字母字符，汉字字符等和数字运算时，字符被视作0（数字字符除外）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span><span class="operator">+</span>a <span class="operator">=</span><span class="number">100</span>；</span><br></pre></td></tr></table></figure><p>null参与的运算结果都为null</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span><span class="operator">+</span><span class="keyword">null</span><span class="operator">=</span><span class="keyword">null</span>；</span><br></pre></td></tr></table></figure><p>对于浮点类型，和java类似，涉及浮点数据的运算mysql也会自动提升转换，输出浮点数据。</p><p>在使用“&#x2F;”的除法中，结果默认为浮点型（不同于java的截地板），使用DIV得到的结果则必为整型。当除法分母为0时，结果为null（MySQL中）</p><p>在取模运算，也就是取余中，得到的只是余数（类似java），其中取余结果的符号与取余符号的左侧相同。</p><h2 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p><img src="/assets/image-20221023145215-bl8ghhd.png" alt="image">共有三种结果，假（0），真（1），Null，类似c而不是java</p><p>比较运算符经常被用来作为SELECT查询语句的条件来使用</p><h3 id="等号运算"><a href="#等号运算" class="headerlink" title="等号运算"></a>等号运算</h3><p>等号运算符（&#x3D;）判断等号两边的值、字符串或表达式是否相等，遵循以下规则</p><ol><li><p>左右均为字符串，MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等</p></li><li><p>有null则null</p></li><li><p>整数和字符串共同存在则字符串转换为数字，非数字字符串会被转换成数字0，</p></li></ol><p>注意！“&#x3D;”是相等判断，“：&#x3D;”才是赋值运算（也就是java的&#x3D;&#x3D;）</p><p>ex.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name,salary <span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">=</span> <span class="number">6000</span>;</span><br></pre></td></tr></table></figure><p>查询salary为6000的包含last_name和salary字段的结果</p><p>注意！对于null，若尝试使用null&#x3D;null去查询，结果是空，因为null的任何等于运算结果都为null，而结果集只会返回比较结果为1的值，该问题可以用安全等于和符号运算等于解决。</p><h3 id="安全等于"><a href="#安全等于" class="headerlink" title="安全等于"></a>安全等于</h3><p>其实很直观的嘛，带了套就安全了</p><p>安全等于运算符“&lt;&#x3D;&gt;”与等于运算符“&#x3D;”的作用是相似的，区别在于是‘&lt;&#x3D;&gt;’可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为 1 ，而不为NULL；当一个操作数为NULL时，其返回值为 0 ，而不为NULL。</p><p>简单来说使用安全等于运算符时，两边的操作数的值都为NULL时，返回的结果为 1 而不是NULL。</p><h3 id="不等于"><a href="#不等于" class="headerlink" title="不等于"></a>不等于</h3><p>使用“！&#x3D;”或&lt;&gt;来表示</p><h2 id="符号运算"><a href="#符号运算" class="headerlink" title="符号运算"></a>符号运算</h2><h3 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h3><p><img src="/assets/image-20221023151925-781tfx1.png" alt="image">​</p><h3 id="is-null系列"><a href="#is-null系列" class="headerlink" title="is null系列"></a>is null系列</h3><p>包括is null，is not null，isnull</p><ol><li>is null和is not null是单目运算，如A is null，则为当A字段（值）为null返回1</li><li>isnull是一个函数，如isnull（A），当A字段（值）为null返回1</li></ol><p>一般来说，对字段的查询多用is null，对数字多用等号和安全等号</p><p>注意！where后可接not或！表示否</p><p>ex.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> xxx <span class="keyword">from</span> yyy</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> （A <span class="operator">&lt;=&gt;</span><span class="keyword">null</span>）；</span><br></pre></td></tr></table></figure><p>其中使用not时括号为了提高可读性而加的，而在使用！时必须加上，这里的A &lt;&#x3D;&gt;null返回值会被not取反</p><h3 id="极值"><a href="#极值" class="headerlink" title="极值"></a>极值</h3><p>Least，求最小值</p><p>语法格式为：LEAST(值 1 ，值 2 ，…，值n)。其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。</p><p>其中，当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p><p>ex.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> least(first_name,last_name) </span><br><span class="line"><span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure><p>对于这些函数，调用时，指定传入first_name,last_name字段，此时表中拥有这两字段的行将会作为类传入这个函数中，也就是说，上面代码的意思是在整个表中，比较每一行的first_name,last_name，输出其中的较小值。</p><p>Greatest于Least大体相似</p><h3 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h3><p>between，一般和and一起使用</p><p>BETWEEN运算符使用的格式通常为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> D <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> C <span class="keyword">BETWEEN</span> A <span class="keyword">AND</span> B;</span><br></pre></td></tr></table></figure><p>此时，当C大于或等于A，并且C小于或等于B时，结果为 1 ，否则结果为 0，也就是说，这是一个闭区间。</p><p>ex.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">BETWEEN</span> <span class="number">2500</span> <span class="keyword">AND</span> <span class="number">3500</span> ;</span><br></pre></td></tr></table></figure><h3 id="In"><a href="#In" class="headerlink" title="In"></a>In</h3><p>包括in和not in，也就是属于和不属于，和between相似，但in更多的是对离散值的查找。</p><p>IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回 1 ，否则返回 0 。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。</p><p>ex.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, salary, manager_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id <span class="keyword">IN</span> ( <span class="number">100</span> , <span class="number">101</span> , <span class="number">201</span> );</span><br></pre></td></tr></table></figure><p>而not in和in类似，如果不是IN列表中的一个值，则返回 1 ，否则返回 0 。</p><h3 id="Like"><a href="#Like" class="headerlink" title="Like"></a>Like</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>也就是模糊查询，通常用于字符串如果满足条件则返回 1 ，否则返回0 。通常如果给定的值或者匹配条件为NULL，则返回结果为NULL。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> last_name <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p>以上是精确查询，返回所有last_name &#x3D; ‘a’的行</p><p>而last常与%或_一起使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“<span class="operator">%</span>”：匹配 <span class="number">0</span> 个或多个字符</span><br><span class="line">“_”：只能匹配一个字符</span><br></pre></td></tr></table></figure><p>如apple和abandoned都可以表示为a%，eat可以表示为_a_或%a%</p><p>ex.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> first_name <span class="keyword">LIKE</span> <span class="string">&#x27;S%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>返回所有first_name为Sxxxxxxxx的结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;_o%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>返回所有满足xoxxxxxxx的结果</p><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>当查询对象本身就是”_”或”%”时，使用转义字符”\&quot;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> job_id</span><br><span class="line"><span class="keyword">FROM</span> jobs</span><br><span class="line"><span class="keyword">WHERE</span> job_id <span class="keyword">LIKE</span> ‘IT\_<span class="operator">%</span>‘;</span><br></pre></td></tr></table></figure><p>也可以使用escape指定转义字符，如下代码则是让$成为了转义字符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> job_id</span><br><span class="line"><span class="keyword">FROM</span> jobs</span><br><span class="line"><span class="keyword">WHERE</span> job_id <span class="keyword">LIKE</span> ‘IT$_<span class="operator">%</span>‘ <span class="keyword">escape</span> ‘$‘;</span><br></pre></td></tr></table></figure><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><h3 id="简述-2"><a href="#简述-2" class="headerlink" title="简述"></a>简述</h3><p><img src="/assets/image-20221023162850-blq1ra9.png" alt="image">​</p><p>注意！逻辑运算两侧表达式应该完整，如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> manager_id <span class="keyword">IN</span> <span class="number">100</span> <span class="keyword">and</span> manager_id <span class="keyword">IN</span>；</span><br></pre></td></tr></table></figure><h3 id="非"><a href="#非" class="headerlink" title="非"></a>非</h3><p>NOT或!</p><p>表示当给定的值为 0 时返回 1 ；当给定的值为非 0 值时返回 0 ；当给定的值为NULL时，返回NULL</p><p>如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> xxx <span class="keyword">from</span> yyy</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> （A <span class="operator">&lt;=&gt;</span><span class="keyword">null</span>）；</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> job_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;IT_PROG&#x27;</span>, <span class="string">&#x27;ST_CLERK&#x27;</span>, <span class="string">&#x27;SA_REP&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="与"><a href="#与" class="headerlink" title="与"></a>与</h3><p>AND或&amp;&amp;</p><p>当给定的所有值均为非 0 值，并且都不为NULL时，返回1 ；当给定的一个值或者多个值为 0 时则返回 0 ；否则返回NULL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, job_id, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;=</span> <span class="number">10000</span></span><br><span class="line"><span class="keyword">AND</span> job_id <span class="keyword">LIKE</span> <span class="string">&#x27;%MAN%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="或"><a href="#或" class="headerlink" title="或"></a>或</h3><p>OR或||</p><p>当给定的值都不为NULL，并且任何一个值为非 0 值时，则返回 1 ，否则返回 0 ；当一个值为NULL，并且另一个值为非 0 值时，返回 1 ，否则返回NULL；当两个值都为NULL时，返回NULL</p><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>XOR</p><p>当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是 0 或者都不等于 0 时，则返回 0 ；如果一个值为 0 ，另一个值不为 0 时，则返回 1</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="简述-3"><a href="#简述-3" class="headerlink" title="简述"></a>简述</h3><p><img src="/assets/image-20221023183247-z9gpyki.png" alt="image">​</p><p>这里可以参见C</p><p><img src="/assets/image-20221023183439-byban0v.png" alt="image">​</p><h3 id="按位与"><a href="#按位与" class="headerlink" title="按位与"></a>按位与</h3><p>按位与（&amp;）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二进制位的数值都为 1 时，则该位返回 1 ，否则返回 0。</p><h3 id="按位或"><a href="#按位或" class="headerlink" title="按位或"></a>按位或</h3><p>按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为 1 时，则该位返回 1 ，否则返回 0 。</p><h3 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或"></a>按位异或</h3><p>按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值对应的二进制位的数值不同时，则该位返回 1 ，否则返回 0 。</p><h3 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反"></a>按位取反</h3><p>按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将 1 变为 0 ，将 0 变为 1 。</p><h3 id="按位移动"><a href="#按位移动" class="headerlink" title="按位移动"></a>按位移动</h3><p>按位右移（&gt;&gt;）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用 0 补齐。</p><p>按位左移类似，只是方向改变</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">10</span> <span class="operator">&amp;</span> <span class="operator">~</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>由于按位取反（~）运算符的优先级高于按位与（&amp;）运算符的优先级，所以 10 &amp; ~ 1 ，首先，对数字 1 进行按位取反操作，结果除了最低位为 0 ，其他位都为 1 ，然后与 10 进行按位与操作，结果为 10。</p><h2 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h2><p><img src="/assets/image-20221023183649-l47r3od.png" alt="image">​</p><p>数字编号越大，优先级越高</p><h2 id="REGEXP"><a href="#REGEXP" class="headerlink" title="REGEXP"></a>REGEXP</h2><p>MySQL中使用REGEXP关键字指定正则表达式的字符匹配模式，REGEXP运算符用来匹配字符串，语法格式为：expr REGEXP 匹配条件。如果expr满足匹配条件，返回1 ；如果不满足，则返回 0 。若expr或匹配条件任意一个为NULL，则结果为NULL。</p><p>注意！匹配条件要用‘xxxx’单引号括起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT <span class="string">&#x27;xxguigu&#x27;</span> REGEXP <span class="string">&#x27;gu.gu&#x27;</span>, <span class="string">&#x27;atguigu&#x27;</span> REGEXP <span class="string">&#x27;[ab]‘</span></span><br></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则"></a>排序规则</h2><ul><li><p>使用 ORDER BY 子句排序</p><ul><li><strong>ASC（ascend）: 升序</strong></li><li><strong>DESC（descend）:降序</strong></li></ul></li><li><p>ORDER BY 子句在SELECT语句的结尾</p></li><li><p>语法顺序应该是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> xxxx</span><br><span class="line"><span class="keyword">from</span> xxxx</span><br><span class="line"><span class="keyword">where</span> xxx <span class="keyword">in</span> xxx</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> xxxx</span><br></pre></td></tr></table></figure></li></ul><p>执行上，顺序是</p><ol><li>from xxx where xxxx</li><li>select（此时才可以指定别名</li><li>order by</li></ol><h2 id="单列排序"><a href="#单列排序" class="headerlink" title="单列排序"></a>单列排序</h2><p>在没有使用排序时，是按照主键的升序来排序的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> employee_id,last_name,</span><br><span class="line">salary <span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure><p>上面是一个普通的查询语句，下面使用order by排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, job_id, department_id, hire_date</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date ;</span><br></pre></td></tr></table></figure><p>默认情况下使用的是升序（省略AES），可以在表名后加上DESC进行降序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, salary<span class="operator">*</span> <span class="number">12</span> annsal</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> annsal;</span><br></pre></td></tr></table></figure><p>注意！对于列的别名</p><p>只能在Order by语句中使用，在其他语句中如Where中都是无效的</p><h2 id="多列排序"><a href="#多列排序" class="headerlink" title="多列排序"></a>多列排序</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, department_id, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id, salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, department_id, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id <span class="keyword">DESC</span>, salary <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p>这样，则是先按照department_id降序排序,当其相同再按照salary升序排序</p><h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><h2 id="简述-4"><a href="#简述-4" class="headerlink" title="简述"></a>简述</h2><p>所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件</p><p>MySQL中使用 LIMIT 实现分页</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT [位置偏移量,] 行数</span><br></pre></td></tr></table></figure><p>第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是 0 ，第二条记录的位置偏移量是1 ，以此类推）；第二个参数“行数”指示返回的记录条数</p><p><strong>注意：LIMIT 子句必须放在整个SELECT语句的最后！</strong></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--前 10 条记录：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 LIMIT <span class="number">0</span> , <span class="number">10</span> ;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 LIMIT <span class="number">10</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--第 11 至 20 条记录：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 LIMIT <span class="number">10</span> , <span class="number">10</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--第 21 至 30 条记录：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 LIMIT <span class="number">20</span> , <span class="number">10</span> ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MySQL <span class="number">8.0</span>中可以使用“LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">4</span>”，</span><br><span class="line">意思是获取从第 <span class="number">5</span> 条记录开始后面的 <span class="number">3</span> 条记录，</span><br><span class="line">和“LIMIT <span class="number">4</span>,<span class="number">3</span>;”返回的结果相同</span><br></pre></td></tr></table></figure><h2 id="分页显示"><a href="#分页显示" class="headerlink" title="分页显示"></a>分页显示</h2><p>分页显式公式 ：（<strong>当前页数- 1 ）*每页条数，每页条数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line">LIMIT(PageNo <span class="operator">-</span> <span class="number">1</span> )<span class="operator">*</span>PageSize,PageSize;</span><br></pre></td></tr></table></figure><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="一对多表"><a href="#一对多表" class="headerlink" title="一对多表"></a>一对多表</h2><p>一个表中的字段，和其他表的字段建立了联系，表和表之间具有了一对多的关系</p><p>分表，目的是减少内存消耗，提高查询效率（参见优化）</p><p><img src="/assets/1649562093193-20221025222331-cqfu8t0.png" alt="1649562093193">​</p><p><img src="/assets/image-20221025222420-oszhmi9.png" alt="image">​</p><h2 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h2><h3 id="简述-5"><a href="#简述-5" class="headerlink" title="简述"></a>简述</h3><p>假设两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数</p><p><img src="/assets/image-20221025223812-7txl18a.png" alt="image">​</p><p>也称作交叉连接（CROSS JOIN）,其作用就是可以把任意表进行连接，即使这两张表不相关</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#案例：查询员工的姓名及其部门名称</span><br><span class="line"><span class="keyword">SELECT</span> last_name, department_name</span><br><span class="line"><span class="keyword">FROM</span> employees, departments;</span><br></pre></td></tr></table></figure><p>这里就涉及了笛卡尔积问题</p><p><img src="/assets/image-20221025223436-1i3xskv.png" alt="image">​</p><p>可以看到每一个last_name都对应了多个department_name，这是因为last和每一个department都匹配了一次，这就是笛卡尔积错误</p><p><img src="/assets/image-20221025222428-t4k833q.png" alt="image">​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#查询员工姓名和所在部门名称</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name <span class="keyword">FROM</span> </span><br><span class="line">employees,departments;</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name <span class="keyword">FROM</span> </span><br><span class="line">employees <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> departments;</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name <span class="keyword">FROM</span> </span><br><span class="line">employees <span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments;</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name <span class="keyword">FROM</span> </span><br><span class="line">employees <span class="keyword">JOIN</span> departments;</span><br></pre></td></tr></table></figure><p>以上都是会出现笛卡尔积错误的情况</p><h3 id="两表的连接条件"><a href="#两表的连接条件" class="headerlink" title="两表的连接条件"></a>两表的连接条件</h3><p>查询employes_id,department_name</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, department_name</span><br><span class="line"><span class="keyword">FROM</span> employees, departments;</span><br></pre></td></tr></table></figure><p>已知这样会产生笛卡尔积问题，则需要使用连接条件（筛选），得到想要的结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, department_name</span><br><span class="line"><span class="keyword">FROM</span> employees, departments</span><br><span class="line"><span class="keyword">where</span> employees.departments_name<span class="operator">=</span>departments.departments_name</span><br></pre></td></tr></table></figure><p><img src="/assets/1649562093193-20221025225640-7ds6czi.png" alt="1649562093193">​</p><p>如图，建立相等时的连接</p><h3 id="指定"><a href="#指定" class="headerlink" title="指定"></a>指定</h3><p>查询employes_id,department_name,dapartment_id；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, department_name,dapartment_id</span><br><span class="line"><span class="keyword">FROM</span> employees, departments;</span><br></pre></td></tr></table></figure><p>此时则会报错，因为department_id在employees和department两表中均存在，对于这次查询来说department_id是模糊的，不知道该从那一张表查询  </p><p><img src="/assets/1649562093193-20221025225640-7ds6czi.png" alt="1649562093193">​</p><p>如图，同时存在，则需要指定查询表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">employees.departments_id</span><br></pre></td></tr></table></figure><p>指定在employees表中查询departments_id</p><p>为什么last_name, department_name可以不指定？因为他们在这次查询中是唯一存在在一张表中的不会模糊，但是实际上是否会模糊都建议加上表名（从sql优化的角度）</p><h2 id="表的别名"><a href="#表的别名" class="headerlink" title="表的别名"></a>表的别名</h2><p>表的别名可以在select和where里使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.employee_id, e.last_name, e.department_id,</span><br><span class="line">d.department_id, d.location_id</span><br><span class="line"><span class="keyword">FROM</span> employees e , departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure><p>由执行顺序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xxx <span class="keyword">where</span> xxxx</span><br><span class="line"><span class="keyword">select</span>（此时才可以指定别名</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br></pre></td></tr></table></figure><p>可知在from中定义了表的别名后，在select和where等中都可以使用，注意！如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错</p><h2 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h2><p>例题</p><p>查询出公司员工的 last_name,department_name, city</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.`department_id`,</span><br><span class="line">employees.`last_name`,</span><br><span class="line">departments.`department_name`,</span><br><span class="line">locations.`city` </span><br><span class="line"><span class="keyword">FROM</span> employees,</span><br><span class="line">departments,locations</span><br><span class="line"><span class="keyword">WHERE</span> employees.`department_id`</span><br><span class="line"><span class="operator">=</span> departments.`department_id`<span class="keyword">AND</span></span><br><span class="line">departments.`location_id` <span class="operator">=</span> </span><br><span class="line">locations.`location_id`;</span><br></pre></td></tr></table></figure><p><img src="/assets/1649562093193-20221025233544-o1jtbxw.png" alt="1649562093193">​</p><p>多（n）表连接需要至少n-1个连接条件，注意！连接条件需要逻辑运算符连接</p><h2 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h2><p>在上面的连接语句中，使用的都是等于条件连接，这样的连接即等值连接，使用其他比较运算符即称为非等值连接</p><p>例</p><p><img src="/assets/image-20221026081308-8chlt9p.png" alt="image">​</p><p>查询每位员工在Job_Grades中的等级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name, e.salary, j.grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e, job_grades j</span><br><span class="line"><span class="keyword">WHERE</span> e.salary <span class="keyword">BETWEEN</span> j.lowest_sal <span class="keyword">AND</span> j.highest_sal;</span><br></pre></td></tr></table></figure><p>返回所有e.salary位于j.lowest_sal AND j.highest_sal之间的结果，当然也可以改写成大于等于小于等于符号；</p><p>最后还可以使用Order by排序</p><p><img src="/assets/image-20221026081514-rsemshz.png" alt="image">​</p><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><h3 id="自我引用"><a href="#自我引用" class="headerlink" title="自我引用"></a>自我引用</h3><p>上面的所有连接都是非自连接，是不同的表进行连接。同时，表中的数据是可以自我引用的，如</p><p><img src="/assets/image-20221026082353-xlr08zx.png" alt="image">​</p><p>这张表里，每一个员工有一个id，员工也有一个主管，主管本身就是员工也有员工id，主管编号和员工编号构成了自我引用。</p><h3 id="进行自连接"><a href="#进行自连接" class="headerlink" title="进行自连接"></a>进行自连接</h3><p>ex.  </p><p>查询员工id，姓名和管理者的id，姓名。</p><p>这个操作可以试看成在两张employees表（物理上本质还是一张表）间连连接，左表的manager_id和右表的employee_id连接，</p><p><img src="/assets/image-20221026083033-xwpzxbh.png" alt="image"><img src="/assets/image-20221026083125-95p46ct.png" alt="image"></p><p>在操作中，为了区别左右表，需要给他们起别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> employees worker,employees manager;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20221026082907-3746kfd.png" alt="image">​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> worker.employee_id,worker.last_name,</span><br><span class="line">manager.employee_id,manager.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees worker,employees manager</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>建立连接</span><br><span class="line"><span class="keyword">WHERE</span> worker.`manager_id` <span class="operator">=</span> manager.`employee_id`;</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="/assets/image-20221026084256-zrlsk41.png" alt="image">​</p><h2 id="内连接和外连接"><a href="#内连接和外连接" class="headerlink" title="内连接和外连接"></a>内连接和外连接</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行。</p><p>简单来说就是结果集只返回满足查询条件的行。</p><p>对于上面非等值连接中的例子可知，存在没有manager的员工，也就是manager为null，这样的行，因为manager表中没有null行，所以其不会通过结果集返回。</p><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><h4 id="简述-6"><a href="#简述-6" class="headerlink" title="简述"></a>简述</h4><p>一般情况，查询所有（员工）的xxx则需要外连接 </p><p>这里使用的是SQL99的语法</p><p><img src="/assets/image-20221026091605-qqdz24e.png" alt="image">​</p><p>如左连接，多显示左表数据，这个时候右表中提取的数据数量就少了，右表不足的部分则返回空</p><p>使用的是join xxxx on语句进行外连接</p><h4 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a><strong>左连接</strong></h4><p>左连接就是将JOIN前面的表中所有记录都展示出来。</p><p>Teachers教师表链接Students学生表，通过教师字段Tid连接。</p><p><img src="/assets/image-20221026104729-a869niw.png" alt="image">​</p><p><img src="/assets/image-20221026104736-mxpx5w2.png" alt="image">​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Teachers <span class="keyword">AS</span> t，Students <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">where</span> t.Tid <span class="operator">=</span> s.Tid；</span><br></pre></td></tr></table></figure><p>结果中只显示了张三和李四两个老师。</p><p>实际上，where就是”join”，也就是内连接，也就是说，使用where语句也能改写成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Teachers <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">JOIN</span> Students <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">ON</span> t.Tid <span class="operator">=</span> s.Tid</span><br></pre></td></tr></table></figure><p>这里的Join就是将两表连接，On，通过某某条件。</p><p>如果我们想要显示所有老师，不管这个老师有没有对应的学生。这个时候就应该用到LEFT JOIN 左连接了。将前面的Teachers表中所有记录都展示出来，也就是Join左侧的表全显示。</p><p>ex.</p><p>Teachers教师表连接Students学生表，通过教师字段Tid连接，老师要全部显示出来</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Teachers <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Students <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">ON</span> t.Tid <span class="operator">=</span> s.Tid</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20221026111852-4m2k4at.png" alt="image">​</p><p>这样就建立了左连接，所有老师都显示出来了</p><h4 id="右连接"><a href="#右连接" class="headerlink" title="右连接"></a>右连接</h4><p>右连接就是将JOIN后面的表中所有记录都展示出来。跟左连接是对应互通的。</p><p>比如我们可以将上面Teachers表和Students表互换，再将LEFT JOIN改成RIGHT JOIN，输出结果基本是一样的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Students <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> Teachers <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">ON</span> t.Tid <span class="operator">=</span> s.Tid</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20221026112214-526dxwe.png" alt="image">​</p><p>与LEFT JOIN输出的记录是一样的，唯一的区别是：</p><p>Students表中的列（Sid、Sname等）在前面，Teachers表中的列（Tid、Tname）在后面，因为Teacher在连接的右侧。</p><h4 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h4><p>FYLL JOIN</p><p>MySQL中不支持 FULL JOIN，实际业务中，基本不用全连接。全连接的结果集结合了 LEFT JOIN 和 RIGHT JOIN 的结果集。简单来说就是不重要。</p><p>MySQL不支持FULL JOIN，但是可以用 LEFT JOIN UNION RIGHT join代替。</p><h2 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h2><p><strong>合并查询结果</strong>利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNION ALL关键字分隔。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>,... <span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>,... <span class="keyword">FROM</span> <span class="keyword">table</span></span><br></pre></td></tr></table></figure><p><img src="/assets/image-20221026122304-ba487b4.png" alt="image">​</p><p>UNION 操作符返回两个查询的结果集的并集，去除重复记录。重复记录只保留一份。</p><p><img src="/assets/image-20221026122335-9zxoj5l.png" alt="image">​</p><p>UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重，也就是交集部分出现两次。</p><p>注意：执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。也就是说尽量使用union on；</p><h2 id="joins"><a href="#joins" class="headerlink" title="joins"></a>joins</h2><p>join可以连接多表，但超过三个表禁止使用join</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">from</span> xxxx <span class="keyword">join</span> xxxx <span class="keyword">on</span> xxxx</span><br><span class="line"><span class="keyword">join</span> xxxx <span class="keyword">on</span> xxxx；</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20221026122721-il44jrb.png" alt="image">​</p><p>由于mysql不支持full join，直接实现左下图和右下图是不行的。</p><p>但是使用union可以实现。</p><p>中图：内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#中图：内连接 A∩B</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>左上图：左外连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#左上图：左外连接</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br></pre></td></tr></table></figure><p>右上图：右外连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#右上图：右外连接</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br></pre></td></tr></table></figure><p>左图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><p><img src="/assets/image-20221026124737-movs1kg.png" alt="image"></p><p>对于这张图，假设A表查询其中的name，id两个字段，B表查询id，department两字段，通过id，AB表建立了连接。此时，做左连接，也就是A脚长，则id和department会使用null补偿，AB的交集必然是非null</p><p>对于上述代码，where筛选保留了department_id为null也就是补偿的行，而非null也就是AB共有的被筛去，留下A中的null；</p><p>简单来说，去掉公共部分，对于公共部分，department_id不可能为空。</p><p>右图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><p>左下：满外连接</p><p>左图与右上图的union</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span> #没有去重操作，效率高</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br></pre></td></tr></table></figure><p>右下：</p><p>左图与右中的union</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><h2 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h2><p>SQL 99 在 SQL 92 的基础上提供了一些特殊语法，比如 ​NATURAL JOIN​ 用来表示自然连接。我们可以把自然连接理解为 SQL 92 中的等值连接。它会帮你自动查询两张连接表中​所有相同的字段​，然后进行​等值连接​。</p><p>在SQL 92 标准中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">AND</span> e.`manager_id` <span class="operator">=</span> d.`manager_id`;</span><br></pre></td></tr></table></figure><p>在 SQL 99 中可以写成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments d;</span><br></pre></td></tr></table></figure><p>这样就自动实现了多表的等值连接</p><h2 id="USING"><a href="#USING" class="headerlink" title="USING"></a>USING</h2><p>当我们进行连接的时候，SQL 99 还支持使用 USING 指定数据表里的同名字段进行等值连接。但是只能配合JOIN一起使用。比如：q</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">USING</span> (department_id);</span><br></pre></td></tr></table></figure><p>你能看出与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING的括号 () 中填入要指定的同名字段。同时使用 JOIN…USING 可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e ,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.department_id; </span><br></pre></td></tr></table></figure><p>也就是说，Using也是一种自动连接，输入字段名即可自动匹配（不能于自连接中使用），使用较少</p><h4 id="成对比较"><a href="#成对比较" class="headerlink" title="成对比较"></a>成对比较</h4><p>查询与 141 号员工的 manager_id,department_id<br>相同的其他员工的信息（同上）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, manager_id, department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> (manager_id, department_id) <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> manager_id, department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="keyword">IN</span> (<span class="number">141</span>,<span class="number">174</span>))</span><br><span class="line"><span class="keyword">AND</span> employee_id <span class="operator">&lt;&gt;</span> <span class="number">141</span>;</span><br></pre></td></tr></table></figure><p>本质区别不大，前提是两个 where 的条件相同，则外查询 where 后括号内内列名可以和内查询 select 后的列名匹配，共有 where 的条件</p><h4 id="having-子查询"><a href="#having-子查询" class="headerlink" title="having 子查询"></a>having 子查询</h4><p>只是将 where 查询改为了 having，本质区别不大</p><p>查询最低工资大于 50 号部门最低工资的部门的部门 id 和其最低工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MIN</span>(salary) <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">50</span>);</span><br></pre></td></tr></table></figure><h4 id="case-子查询"><a href="#case-子查询" class="headerlink" title="case 子查询"></a>case 子查询</h4><p>显式员工的 employee_id,last_name 和 location。其中，若员工 department_id 与 location_id 为 1800 的 department_id 相同，则 location 为’Canada’，其余则为’USA’</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name,</span><br><span class="line">(<span class="keyword">CASE</span> department_id</span><br><span class="line"><span class="keyword">WHEN</span></span><br><span class="line">(<span class="keyword">SELECT</span> department_id <span class="keyword">FROM</span> departments </span><br><span class="line"><span class="keyword">WHERE</span> location_id <span class="operator">=</span> <span class="number">1800</span>)</span><br><span class="line"><span class="keyword">THEN</span> <span class="string">&#x27;Canada&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;USA&#x27;</span> <span class="keyword">END</span>) location</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><h2 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h2><h3 id="简述-7"><a href="#简述-7" class="headerlink" title="简述"></a>简述</h3><ul><li>也称为集合比较子查询</li><li>内查询返回多行</li><li>使用多行比较操作符</li></ul><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>IN</td><td>等于列表中的<strong>任意一个</strong></td></tr><tr><td>ANY</td><td>需要和单行比较操作符一起使用，和子查询返回的 <strong>某一个</strong> 值比较</td></tr><tr><td>ALL</td><td>需要和单行比较操作符一起使用，和子查询返回的 <strong>所有</strong> 值比较</td></tr><tr><td>SOME</td><td>实际上是 ANY 的别名，作用相同，一般常使用 ANY</td></tr></tbody></table><p>这里要注意 any 和 all 的区别</p><p>这些运算符都搭配单行运算符使用</p><h3 id="使用例"><a href="#使用例" class="headerlink" title="使用例"></a>使用例</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>返回其它 job_id 中比 job_id 为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及 salary</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> job_id,employee_id,last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> <span class="keyword">ANY</span> (</span><br><span class="line"><span class="keyword">SELECT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> job_id <span class="operator">&lt;&gt;</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br></pre></td></tr></table></figure><p>返回其它 job_id 中比 job_id 为‘IT_PROG’部门所有工资低的员工的员工号、姓名、job_id 以及 salary</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> job_id,employee_id,last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> <span class="keyword">ALL</span> (</span><br><span class="line"><span class="keyword">SELECT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> job_id <span class="operator">&lt;&gt;</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br></pre></td></tr></table></figure><p>当然也可使用单行函数</p><h4 id="FROM-和子查询"><a href="#FROM-和子查询" class="headerlink" title="FROM 和子查询"></a>FROM 和子查询</h4><p>注意！子查询结果可做 from 的表，或者说，查询结果就是一张表。</p><p>查询平均工资最低的部门 id</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(avg_sal)</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) avg_sal</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) dept_avg_sal</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里是把子查询的结果作为新表放到 from 后，在子查询结果集里查询</p><p>最内层</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) avg_sal</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) dept_avg_sal</span><br></pre></td></tr></table></figure><p>查询平均工资，起别名为 avg_sal（这里是为了外层的 MIN 能够通过别名调用平均工资列），后以 department_id 分组，给结果集(表）起别名为 dept_avg_sal（必须给结果集起别名才能在 from 里使用）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(avg_sal)</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) avg_sal</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) dept_avg_sal</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在该结果集里找到最低工资（也就是最低平均工资），外层有平均工资等于该最低工资，找到最低平均工资的部门</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#方式 <span class="number">2</span> ：</span><br><span class="line"><span class="keyword">SELECT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">&lt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) avg_sal</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>方式二，也就是找到一个部门，他的平均工资小于等于所有（任意）部门的平均工资</p><h2 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h2><h3 id="简述-8"><a href="#简述-8" class="headerlink" title="简述"></a>简述</h3><p>上面的案例查询都是不相关子查询，没有涉及到不相关子查询。</p><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为​关联子查询​。</p><p>在上面的非相关子查询中，执行顺序是：</p><ol><li>内查询执行，返回结果集</li><li>外查询执行，外查询的每一行都和内查询的结果比较</li></ol><p>在相关子查询中，相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询</p><p><img src="/assets/image-20221027193116-yangl45.png" alt="image">​</p><ol><li>取外表中的一条记录（获取候选列）</li><li>送入子查询，子查询运行</li><li>返回子查询结果和送入的结果，对 where 条件判断是否符合，不符合则筛选此记录</li></ol><h3 id="使用例-1"><a href="#使用例-1" class="headerlink" title="使用例"></a>使用例</h3><p>查询员工中工资大于本部门平均工资的员工的 last_name,salary 和其 department_id</p><p><img src="/assets/image-20221027193614-falsjgh.png" alt="image">​</p><p>在from语句，指定了employees作为outer（这是个别名，可以是任取），首先，employees里的第一条数据被取入到内循环中，执行查找语句根据department_id查找平均工资，此时例如传入id为90，对于内查询的where语句，则会在内查询中筛选出id为90的结果，再进入外查询，筛选符合条件的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees e2</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> e1.department_id</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>总之，可以视作双层for循环</p><p>另外，也可以使用from子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary,e1.department_id</span><br><span class="line"><span class="keyword">FROM</span> employees e1,(<span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) dept_avg_sal <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id) e2</span><br><span class="line"><span class="keyword">WHERE</span> e1.`department_id` <span class="operator">=</span> e2.department_id</span><br><span class="line"><span class="keyword">AND</span> e2.dept_avg_sal <span class="operator">&lt;</span> e1.`salary`;</span><br></pre></td></tr></table></figure><p>from型的子查询：子查询是作为from的一部分，子查询要用()引起来，并且要给这个子查询取别名， 把它当成一张“临时的虚拟的表”来使用。</p><p>内层select</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br></pre></td></tr></table></figure><p>返回各个部门的平均工资，在外层from里，基于这个结果集，筛选e1也就是完整的employees表中salary低于均值的记录，返回。</p><p>from式使用得会更多</p><h4 id="Order-by子查询"><a href="#Order-by子查询" class="headerlink" title="Order by子查询"></a>Order by子查询</h4><p>查询员工的id,salary,按照department_name 排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (</span><br><span class="line"><span class="keyword">SELECT</span> department_name</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>注意！除group up和limit外，其他地方都可以使用子查询</p><h4 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h4><p>若employees表中employee_id与job_history表中employee_id相同的数目不小于 2 ，输出这些相同id的员工的employee_id,last_name和其job_id</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.employee_id, last_name,e.job_id</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">2</span> <span class="operator">&lt;=</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> job_history</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> e.employee_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="EXISTS-与-NOT-EXISTS"><a href="#EXISTS-与-NOT-EXISTS" class="headerlink" title="EXISTS 与 NOT EXISTS"></a>EXISTS 与 NOT EXISTS</h3><p>关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。</p><ul><li><p><strong>如果在子查询中不存在满足条件的行：</strong></p><ul><li>条件返回 FALSE</li><li>继续在子查询中查找</li></ul></li><li><p><strong>如果在子查询中存在满足条件的行：</strong></p><ul><li>不在子查询中继续查找</li><li>条件返回 TRUE</li></ul></li><li><p>NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。</p></li></ul><p><strong>查询公司管理者的employee_id，last_name，job_id，department_id信息</strong></p><ol><li><p>使用自连接</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> e1.employee_id, e1.last_name, e1.job_id, e1.department_id</span><br><span class="line"><span class="keyword">FROM</span> employees e1 <span class="keyword">JOIN</span> employees e</span><br><span class="line"><span class="keyword">WHERE</span> e1.employee_id <span class="operator">=</span> e2.manager_id;</span><br></pre></td></tr></table></figure></li><li><p>子查询（无exist）</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> manager_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>exist</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, job_id, department_id</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> ( <span class="keyword">SELECT</span> <span class="number">1</span><span class="operator">/</span><span class="operator">/</span>这里不重要<span class="keyword">select</span>都行</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">WHERE</span> e2.manager_id <span class="operator">=</span></span><br><span class="line">e1.employee_id);</span><br></pre></td></tr></table></figure></li></ol><p>方式三是关联子查询和exist的结合，相较于无exist的关联子查询，这种方式在内查询结果不匹配时返回false，继续执行，一旦符合，返回ture，停止不在向后执行。</p><p><strong>查询departments表中，不存在于employees表中的部门的department_id和department_name</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, department_name</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="string">&#x27;X&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> d.department_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE，也就是说，not exist只接收不满足某条件的记录</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2023/01/21/MyBatis/"/>
      <url>/2023/01/21/MyBatis/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul><li>MyBatis 支持定制化 SQL、存储过程以及高级映射(字段和属性不一致，一对多或多对一映射)</li><li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及结果集解析操作</li><li>MyBatis 可以使用简单的 XML 或注解实现配置和原始映射；将接口和 Java 的 POJO（Plain Ordinary Java Object，普通的 Java 对象）映射成数据库中的记录</li><li>Mybatis 是一个半自动的 ORM（Object Relation Mapping）框架(对象-关系映射)</li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="Maven-导入依赖"><a href="#Maven-导入依赖" class="headerlink" title="Maven 导入依赖"></a>Maven 导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Mybatis核心 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h2><p>Mybatis 全局配置文件</p><p>习惯上命名为 mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合 Spring 之后，这个配置文件可以省略。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!-- Mybatis的内置的事务管理器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">                <span class="comment">&lt;!-- 建立数据库连接的具体信息 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;atguigu&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/EmployeeMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>存放的位置是 src&#x2F;main&#x2F;resources 目录下</p><h2 id="Mapper-接口"><a href="#Mapper-接口" class="headerlink" title="Mapper 接口"></a>Mapper 接口</h2><p>Mybatis 中的 Mapper 接口相当于以前的 Dao。但是区别在于，Mapper 仅仅只是建接口即可，我们不需要提供实现类。</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230114101543-4g7apsh.png" alt="image">​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmployeeMapper</span> &#123;</span><br><span class="line">  </span><br><span class="line">    Employee <span class="title function_">selectEmployee</span><span class="params">(Integer empId)</span>;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mybatis-映射文件"><a href="#Mybatis-映射文件" class="headerlink" title="Mybatis 映射文件"></a>Mybatis 映射文件</h2><p>相关概念：ORM（Object Relationship Mapping）对象关系映射。</p><ul><li>对象：Java 的实体类对象</li><li>关系：关系型数据库</li><li>映射：二者之间的对应关系</li></ul><p>下表列举的是最简单的单表映射（一个表和一个类）：</p><table><thead><tr><th>Java 概念</th><th>数据库概念</th></tr></thead><tbody><tr><td>类</td><td>表</td></tr><tr><td>属性</td><td>字段&#x2F;列</td></tr><tr><td>对象</td><td>记录&#x2F;行</td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mapper是根标签，namespace属性：在Mybatis全局范围内找到一个具体的Mapper配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入接口后，为了方便通过接口全类名来找到Mapper配置文件，所以通常将namespace属性设置为接口全类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.mybatis.dao.EmployeeMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployee&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符，在#&#123;&#125;内部还是要声明一个见名知意的名称 --&gt;</span></span><br><span class="line">        select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;empId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：EmployeeMapper.xml 所在的目录要和 mybatis-config.xml 中使用 mapper 标签配置的一致</p><p>一张表——–&gt; 实体类 —-&gt; 对应当前的 mapper 接口—-对应一个映射文件  *mapper 接口中的方法—–&gt; 对应映射文件中的 SQL 语句</p><h2 id="添加测试"><a href="#添加测试" class="headerlink" title="添加测试"></a>添加测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectEmployee</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 1.创建SqlSessionFactory对象</span></span><br><span class="line">    <span class="comment">// ①声明Mybatis全局配置文件的路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mybatisConfigFilePath</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ②以输入流的形式加载Mybatis配置文件</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(mybatisConfigFilePath);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ③基于读取Mybatis配置文件的输入流创建SqlSessionFactory对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2.使用SqlSessionFactory对象开启一个会话</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 3.根据Mapper配置文件的名称空间+SQL语句的id找到具体的SQL语句</span></span><br><span class="line">    <span class="comment">// 格式是：名称空间.SQL语句的id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="string">&quot;com.atguigu.mybatis.dao.EmployeeMapper.selectEmployee&quot;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 要传入SQL语句的参数</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">empId</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 执行SQL语句</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> session.selectOne(statement, empId);</span><br><span class="line">  </span><br><span class="line">    System.out.println(<span class="string">&quot;o = &quot;</span> + result);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 4.关闭SqlSession</span></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SqlSession：代表 Java 程序和数据库之间的会话。（HttpSession 是 Java 程序和浏览器之间的会话）</li><li>SqlSessionFactory：是“生产”SqlSession 的“工厂”。</li><li>工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUsrMapperInterface</span><span class="params">()</span> &#123;</span><br><span class="line">    补充测试方法</span><br><span class="line">    <span class="comment">// 1.根据EmployeeMapper接口的Class对象获取Mapper接口类型的对象</span></span><br><span class="line">    <span class="type">EmployeeMapper</span> <span class="variable">employeeMapper</span> <span class="operator">=</span> session.getMapper(EmployeeMapper.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.调用EmployeeMapper接口的方法完成对数据库的操作</span></span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> employeeMapper.selectEmployee(<span class="number">1L</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 3.打印查询结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;emp = &quot;</span> + emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭前最后提交事务：sqlSession.commit();</p><p>另外还有一仲不使用接口的方式，sqlSession 可以调用如 insert 等方法，接受参数为 namespace.sqlId;</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230114132245-w3wcn6f.png" alt="image">​</p><p>在获取 sqlSession 时 <code> SqlSession session = sessionFactory.openSession();</code>​，这个方法接受一个参数来设置<strong>自动提交，true表示自动提交；</strong></p><p>其他的 update 等都是类似的，这时我们的 sql 还都是静态的；</p><h2 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h2><p>日志级别</p><p>FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试)，从左到右打印的内容越来越详细</p><p>STDOUT</p><p>是 standard output 的缩写，意思是标准输出。对于 Java 程序来说，打印到标准输出就是打印到控制台。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  &lt;select id=<span class="string">&quot;getUserById&quot;</span>&gt;</span><br><span class="line">      select * from t_user <span class="type">where</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">User <span class="title function_">getUserById</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>这时我们考虑返回值如何拿到；我们要通过 ResultMap&#x2F;Type 来解决；要在 select 标签中声明 ResultType;（Result 是自定义映射）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getUserById&quot;</span> resultType=<span class="string">&quot;com.hkk.mybatis.pojo.User&quot;</span>&gt;</span><br><span class="line">    select * from t_user <span class="type">where</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>ResultType，查询结果为 java 对应类型；</p><p>如果是多行查询，但是 java 中有对应实体类，那么，resultType 也还是 list 中的元素的类型而不是 list 类型，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getUserById&quot;</span> resultType=<span class="string">&quot;com.hkk.mybatis.pojo.User&quot;</span>&gt;</span><br><span class="line">      select * from t_user where id &gt;=<span class="number">1</span>;</span><br><span class="line">  &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>目前这样的查询只会返回一个对象，想要返回 list 还需要修改；</p><h1 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h1><h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><p>用于设置环境</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">&lt;!-- Mybatis的内置的事务管理器 类型一个是JDBC一个是MANAGED--&gt;</span></span><br><span class="line">jdbc是原生管理，比如手动设置提交等</span><br><span class="line">mannaged是被管理的，比如后继用Spring管理；</span><br><span class="line">           <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">这个type设置数据源类型，有POLLED，UNPOLLED，JNDI</span><br><span class="line">分别表示数据库连接池，非连接池， 使用上下文的数据源</span><br><span class="line">==================</span><br><span class="line">           <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">&lt;!-- 建立数据库连接的具体信息 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abc123&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 建立数据库连接的具体信息 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abc123&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这一段内容可以用 properties 文件配置；</p><p>jdbc.properties:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC&amp;amp;characterEncoding=utf8</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">abc123</span></span><br></pre></td></tr></table></figure><p>引入配置：在核心配置中</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;configuration&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&lt;properties</span> <span class="string">resource=&quot;jdbc.properties&quot;/&gt;</span></span><br><span class="line">    <span class="attr">&lt;!--</span> <span class="string">environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt;</span></span><br><span class="line">    <span class="attr">&lt;environments</span> <span class="string">default=&quot;development&quot;&gt;</span></span><br></pre></td></tr></table></figure><p>这样，我们就可以在核心配置文件中用 ${key}的方式访问 value</p><p>总之 properties 标签的作用就是引入 properties 文件；</p><h2 id="typeAliases-类型别名"><a href="#typeAliases-类型别名" class="headerlink" title="typeAliases 类型别名"></a>typeAliases 类型别名</h2><p>比如各种全类名(resultType 等)；</p><typeAliases><p>‍</p><p>‍</p><pre><code>&lt;typeAlias type=&quot;原类名&quot; alisa=&quot;别名&quot;&gt;</code></pre><p>作用范围包括核心配置文件，sql 语句等；</p><p>当只设置 type 而不设置 alisa 时，会给一个默认别名，比如 com.xxx.user，那么他的别名默认就是 user 和 User，不区分大小写</p><p>在 typeAliases 标签里还有一个 <package> 标签，属性 name，name 就是包名，表示这个包下面的所有类<strong>都会被赋默认别名</strong></p><h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2><p>mapper 和别名类似，也可以以包为单位设置映射文件引入；但需要满足：</p><ol><li>mapper 接口和映射文件必须在同一个包下</li><li>接口名和对应映射文件名必须相同</li></ol><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230114151136-vrq6l83.png" alt="image">​</p><p>resources 这个 mapper 一定要和 java 上面的个 mapper 一致</p><h1 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h1><h2 id="方式"><a href="#方式" class="headerlink" title="#{}方式"></a>#{}方式</h2><p>Mybatis 会在运行过程中，把配置文件中的 SQL 语句里面的#{}转换为“?”占位符，发送给数据库执行。</p><p>配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;delete</span> <span class="string">id=&quot;deleteEmployeeById&quot;&gt;</span></span><br><span class="line">    <span class="attr">delete</span> <span class="string">from t_emp where emp_id=#&#123;empId&#125;</span></span><br><span class="line"><span class="attr">&lt;/delete&gt;</span></span><br></pre></td></tr></table></figure><p>实际执行的就是：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">delete</span> <span class="string">from t_emp where emp_id=?</span></span><br></pre></td></tr></table></figure><h2 id="方式-1"><a href="#方式-1" class="headerlink" title="${}方式"></a>${}方式</h2><p>和#{}不同，这仲方式会产生 SQL 注入的问题，原理就是字符串拼接</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="attr">&lt;select</span> <span class="string">id=&quot;selectEmployeeByName&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt;</span></span><br><span class="line">    <span class="attr">select</span> <span class="string">emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_name like &#x27;%$&#123;empName&#125;%&#x27;</span></span><br><span class="line"><span class="attr">&lt;/select&gt;</span></span><br></pre></td></tr></table></figure><h2 id="获取参数的几种情况"><a href="#获取参数的几种情况" class="headerlink" title="获取参数的几种情况"></a>获取参数的几种情况</h2><h3 id="简单类型的单参数"><a href="#简单类型的单参数" class="headerlink" title="简单类型的单参数"></a>简单类型的单参数</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;select</span> <span class="string">id=&quot;getUserByUsername&quot; resultType=&quot;com.hkk.mybatis.pojo.User&quot;&gt;</span></span><br><span class="line">     <span class="attr">select</span> <span class="string">* from t_user where username =  #&#123;username&#125;;</span></span><br><span class="line"> <span class="attr">&lt;/select&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">User</span> <span class="string">getUSerByUsername(String username);</span></span><br></pre></td></tr></table></figure><p>#{username}配置文件中的这里，括号内的形参名和查询操作是无关的，但一般建议同名；</p><p>另外的，使用 ${ }时除了 sql 注入问题，还要注意引号，比如 String，Date 在 SQL 查询时应该加上引号,如‘${xxxxx}’,但是#是占位符形式，则无需关注引号了；总之一般情况下，能#就#，不能才$;</p><h3 id="简单类型的多参数"><a href="#简单类型的多参数" class="headerlink" title="简单类型的多参数"></a>简单类型的多参数</h3><p>和单参数不同，多参数的 mybatis 的 SQL 语句里的参数需要使用下面的方法调用</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;select</span> <span class="string">id=&quot;checkLogin&quot; resultType=&quot;user&quot;&gt;</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from t_user where username= #&#123;arg0&#125;</span></span><br><span class="line"><span class="attr">and</span> <span class="string">password = #&#123;arg1&#125;;</span></span><br><span class="line"><span class="attr">&lt;select&gt;</span></span><br></pre></td></tr></table></figure><p>这样调用时，输入的两个参数就是按照 0 开始，按顺序放入 sql 语句中；</p><p>另外也可以使用 param1 到 2，3 等来调用；</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;select</span> <span class="string">id=&quot;checkLogin&quot; resultType=&quot;user&quot;&gt;</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from t_user where username= #&#123;param1&#125;</span></span><br><span class="line"><span class="attr">and</span> <span class="string">password = #&#123;param2&#125;;</span></span><br><span class="line"><span class="attr">&lt;select&gt;</span></span><br></pre></td></tr></table></figure><p>这是由于 mabatis 的参数是由一个 map 存放的，以两种方式 argx 和 paramx 为 key，value 为实际参数；arg0，arg1….param1，param2….</p><h3 id="以-map-作为参数"><a href="#以-map-作为参数" class="headerlink" title="以 map 作为参数"></a>以 map 作为参数</h3><p>接口方法，传入一个 map</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">User</span> <span class="string">checkLoginByMap(Map&lt;String,Object&gt; map);</span></span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;select</span> <span class="string">id=&quot;checkLoginByMap&quot; resultType=&quot;com.hkk.mybatis.pojo.User&quot;&gt;</span></span><br><span class="line">    <span class="attr">select</span> <span class="string">* from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span></span><br><span class="line"><span class="attr">&lt;/select&gt;</span></span><br></pre></td></tr></table></figure><p>当调用时，只需要传入一个 map，包含两个元素，分别以 username 和 password 为 key，那么这样这个 sql 语句就可以调用到这里面的 value 了；</p><h3 id="实体类型参数"><a href="#实体类型参数" class="headerlink" title="实体类型参数"></a>实体类型参数</h3><p>在 mybatis 里，所谓实体类的属性，实际上是 get&#x2F;set 方法去掉前缀后剩余的部分，转为小写；比如 getId，对应 id 这个属性；只和 get 和 set 方法有关；比如</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">public</span> <span class="string">void getId（）&#123;</span></span><br><span class="line"><span class="attr">return</span> <span class="string">name；</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>在这个 get 方法里，返回的是类的 name 成员变量，但是作为属性，这个 name 就是 id 这个属性；</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;insert</span> <span class="string">id=&quot;insertUser&quot;&gt;</span></span><br><span class="line">    <span class="attr">insert</span> <span class="string">into t_user (id, username, password, age, gender, email)</span></span><br><span class="line">    <span class="attr">values</span> <span class="string">(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;gender&#125;,#&#123;email&#125;);</span></span><br><span class="line"><span class="attr">&lt;/insert&gt;</span></span><br></pre></td></tr></table></figure><p>这里的#{username}等，就会调用传入对象的 getxxx 方法，获得一个值，填充到 sql 里；</p><h3 id="注解获取参数"><a href="#注解获取参数" class="headerlink" title="注解获取参数"></a>注解获取参数</h3><p>java 接口</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">User</span> <span class="string">checkLoginByParam(String username,String password);</span></span><br></pre></td></tr></table></figure><p>我们可以在这个接口上加上注解：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">User</span> <span class="string">checkLoginByParam(</span></span><br><span class="line"><span class="attr">@Param(&quot;username&quot;)String</span> <span class="string">username,</span></span><br><span class="line"><span class="attr">@Param(&quot;passworld&quot;)String</span> <span class="string">password);</span></span><br></pre></td></tr></table></figure><p>@Param(xxx)这个注解会把注解内容xxx作为底层map的key，这样，就在配置里，#{xxx}就可以直接找到对应的value，这使我们可以自定义map</p><h1 id="查询返回"><a href="#查询返回" class="headerlink" title="查询返回"></a>查询返回</h1><h2 id="单个简单类型"><a href="#单个简单类型" class="headerlink" title="单个简单类型"></a>单个简单类型</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;select</span> <span class="string">id=&quot;selectEmpCount&quot; resultType=&quot;int&quot;&gt;</span></span><br><span class="line">    <span class="attr">select</span> <span class="string">count(*) from t_emp</span></span><br><span class="line"><span class="attr">&lt;/select&gt;</span></span><br></pre></td></tr></table></figure><p>非常常规，调用返回一个int；</p><p>Mybatis 内部给常用的数据类型设定了很多别名。 以 int 类型为例，可以写的名称有：int、integer、Integer、java.lang.Integer、Int、INT、INTEGER 等等。</p><h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">User</span> <span class="string">getUserById(@Param(&quot;id&quot;) Integer id);</span></span><br></pre></td></tr></table></figure><p>习惯给方法加上注解</p><p>配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;select</span> <span class="string">id=&quot;getUserById&quot; resultType=&quot;user&quot;&gt;</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from t_user where id = #&#123;id&#125;</span></span><br><span class="line"><span class="attr">&lt;select&gt;</span></span><br></pre></td></tr></table></figure><p>在查询时，如果查询的是一个实体类对象，那么就会返回一个user对象，如果是多个结果且都属于一个实体类，那么就返回一个list；</p><p>注意，返回值为多的时候，接口的返回值就应该是List，用User类尝试去接收List会导致报错；</p><p>增删改操作返回的受影响行数：直接使用 int 或 long 类型接收即可</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>适用于SQL查询返回的各个字段综合起来并不和任何一个现有的实体类对应，没法封装到实体类对象中。<strong>能够封装成实体类类型的，就不使用Map类型。</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Map&lt;String,Object&gt;</span> <span class="string">selectEmpNameAndMaxSalary();</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;!--</span> <span class="string">Map&lt;String,Object&gt; selectEmpNameAndMaxSalary(); --&gt;</span></span><br><span class="line"><span class="attr">&lt;!--</span> <span class="string">返回工资最高的员工的姓名和他的工资 --&gt;</span></span><br><span class="line"><span class="attr">&lt;select</span> <span class="string">id=&quot;selectEmpNameAndMaxSalary&quot; resultType=&quot;map&quot;&gt;</span></span><br><span class="line">        <span class="attr">SELECT</span></span><br><span class="line">            <span class="attr">emp_name</span> <span class="string">员工姓名,</span></span><br><span class="line">            <span class="attr">emp_salary</span> <span class="string">员工工资,</span></span><br><span class="line">            <span class="attr">(SELECT</span> <span class="string">AVG(emp_salary) FROM t_emp) 部门平均工资</span></span><br><span class="line">        <span class="attr">FROM</span> <span class="string">t_emp WHERE emp_salary=(</span></span><br><span class="line">            <span class="attr">SELECT</span> <span class="string">MAX(emp_salary) FROM t_emp</span></span><br><span class="line">        <span class="attr">)</span></span><br><span class="line"><span class="attr">&lt;/select&gt;</span></span><br></pre></td></tr></table></figure><p>这样返回的就是一个map,在这个map里，key为字段名，value为实际的值，当然这里只是单行查询的情况；<strong>当查询返回null为value时，null不会被加入到map中；</strong></p><p>在多条map时， 这样回报错，也就是说多条数据不能直接塞到同一个map里；可以用List集合接收；</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">List&lt;Map&lt;String,Object&gt;&gt;</span> <span class="string">getAllUserToMap();</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapper.getAllUserToMap();</span><br></pre></td></tr></table></figure><p>返回一个List，List里又包含多个Map；</p><p>或者，我们会使用MapKey注解，用Map来放Map，通过mapkey来指定一个属性作为key；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line">Map&lt;String,Object&gt; <span class="title function_">getAllUserToMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>这时输出的大map，key为id，value为一个map，这个map里也包含了这个id；</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230116160207-rd0ioew.png" alt="image">​</p><p>这个大key要注意不可重复性；</p><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230116161312-d08y1mv.png" alt="image">​</p><p>都是拼接字符串实现，其中使用较多的是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> xxx <span class="keyword">where</span> xxx <span class="keyword">like</span> &quot;%&quot;#&#123;xxx&#125;&quot;%&quot;</span><br></pre></td></tr></table></figure><h2 id="用添加功能获取自增主键"><a href="#用添加功能获取自增主键" class="headerlink" title="用添加功能获取自增主键"></a>用添加功能获取自增主键</h2><p>例如功能，有两表clazz班级表和student学生表；要实现这样一个功能：</p><ol><li>添加班级</li><li>获取新添加的班级id(id是自增主键，不是我们输入的)</li><li>为班级分配学生，也就是把学生的班级id修改为新添加的般的的id；</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void insertUser(<span class="keyword">User</span> <span class="keyword">user</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">insert</span> id<span class="operator">=</span>&quot;insertUser&quot; useGeneratedKeys<span class="operator">=</span>&quot;true&quot; keyProperty<span class="operator">=</span>&quot;id&quot;<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 。。。常规<span class="keyword">sql</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">insert</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>这里涉及到两个参数：useGeneratedKeys&#x3D;”true” 和keyProperty&#x3D;”id”,前者表示”允许返回自增主键的值”，至于后者，首先jdbc中增删改的返回值一定是修改数据的行数，至于如何拿到这个主键，则需要通过传入对象来获取；</p><p>比如，user需要id，gender，name这三个属性，而id自增，则调用时只需要传入<strong>null</strong>，性别，姓名这样的参数，在方法调用后，<strong>null就会修改为自增主键的值，执行前无id，执行后有id</strong>；实际上赋值给哪个参数都是允许的；</p><h1 id="自定义映射"><a href="#自定义映射" class="headerlink" title="自定义映射"></a>自定义映射</h1><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>SQL表的列名和类的属性名不一致时，需要创建自定义映射；传统的，可以使用<strong>别名</strong>的方式解决；</p><p>一般SQL的列名是xxx_xxx的命名规则，而java中的属性，一般是xxxXxx的命名；<strong>Mybatis的核心配置里&lt;setting&gt;可以设置一个全局配置</strong>，可以自动把下划线命名映射到驼峰命名；</p><p>&lt;seeting name&#x3D;”mapUdenerscoreToCamelCase” value&#x3D;”true”&#x2F;&gt;</p><p>比如emp_id就会映射为empId，user_name就是userName；</p><h2 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h2><p>使用resultMap标签定义对应关系，再在后面的SQL语句中引用这个对应关系，注意这里对于主键属性和非主键属性的处理是不一样的；(id和colum)</p><p>在配置文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 专门声明一个resultMap设定column到property之间的对应关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByRMResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 使用id标签设置主键列和主键属性之间的对应关系 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- column属性用于指定字段名；property属性用于指定Java实体类属性名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;emp_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empId&quot;</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 使用result标签设置普通字段和Java实体类属性之间的关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_salary&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empSalary&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- Employee selectEmployeeByRM(Integer empId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByRM&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;selectEmployeeByRMResultMap&quot;</span>&gt;</span></span><br><span class="line">    select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样返回时返回的就是特定的resultMap, 对于结果，key就是指定的id，value就是上面的属性，最后返回的就是<code>&lt;resultMap id=&quot;selectEmployeeByRMResultMap&quot; type=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; </code>​，这里所对应的类Employee；</p><h1 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h1><h2 id="数量和方向"><a href="#数量和方向" class="headerlink" title="数量和方向"></a>数量和方向</h2><ol><li><p>数量关系</p><p> 主要体现在数据库表中</p><p> 一对一</p><p> 夫妻关系，人和身份证号</p><p> 一对多<br> 用户和用户的订单，锁和钥匙</p><p> 多对多<br> 老师和学生，部门和员工</p></li><li><p>方向</p><p> 主要体现在Java实体类中</p><ul><li><p>双向：双方都可以访问到对方</p><ul><li>Customer：包含Order的集合属性</li><li>Order：包含单个Customer的属性</li></ul></li><li><p>单向：双方中只有一方能够访问到对方</p><ul><li>Customer：不包含Order的集合属性，访问不到Order</li><li>Order：包含单个Customer的属性</li></ul></li></ul></li></ol><p>简单来说，一对一对应的就是一个对象，一对多对应的就是一个集合；</p><h2 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h2><p>比如Emp员工类包含几个属性：empId，empName，age，gender和一个Dept类型的部门属性，但是就表结构来说，通过join查询得到的数据是empId，empName，age，gender和Dpet表获取的deptName共五个数据，那么如何把deptName属性给到Dept类型呢；</p><p>SQL</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230116233342-ck86f8r.png" alt="image">​</p><p>表结构</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230116233445-ffizstd.png" alt="image">​</p><p>结果例</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230116233515-v1i6imn.png" alt="image">​</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230116233536-m8ionyt.png" alt="image"></p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230116233745-vydie2p.png" alt="image">​</p><p>也就是说，dept_name显然和Dept这个class是不对应的，要解决的就是<strong>如何将字段直接映射成对象属性的问题</strong>；</p><h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><p>必须使用resultMap处理；处理Emp类型的映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptResultMap&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">Emp本身的属性映射略，重点关注Dept</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.deptId&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span>&gt;</span></span><br><span class="line">这里的dept就是Emp这个类内的一个属性，</span><br><span class="line">也就是Dept类-dept，通过dept来调其中的属性dept_id;</span><br><span class="line">dept_name也是同理的</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230116234328-91pxn1x.png" alt="image">​</p><p>这样，结果就可以查询出来了(注意先重写toString方法)</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230116234905-gb9f1qw.png" alt="image">​</p><p>切记，这里的resultMap是映射给Emp，给Emp内的特殊属性Dept，再调用内部的属性映射；</p><h3 id="association"><a href="#association" class="headerlink" title="association"></a>association</h3><p>用于处理实体类类型的属性，包括一对一，多对一；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">指定sql查询出来的字段名</span></span></span><br><span class="line"><span class="tag"><span class="attr">javaType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">映射到的java实体类，也就是属性的类型</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span> = <span class="string">&quot;dept_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">主键-dept_id指向为Dept类型下的deptId属性；</span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span> = <span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span>&gt;</span></span><br><span class="line">非主键属性，映射；</span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这就是association的配置</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230117115627-2b5u927.png" alt="image">​</p><h3 id="分步查询"><a href="#分步查询" class="headerlink" title="分步查询"></a>分步查询</h3><p>首先，第一个sql</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span>&gt;</span></span><br><span class="line">          select * from t_emp where emp_id = #&#123;empId&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 和常规的select一样，返回一个结果集，重点就在于这个结果集的配置，在这个sql里，查询到的是emp表的所有信息；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;emp_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">select</span>=<span class="string">&quot;&quot;</span> <span class="attr">column</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在resultmap的association标签里，又引入了几个新属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select=&quot;&quot; column=&quot;&quot;</span><br></pre></td></tr></table></figure><p>select绑定第二个sql语句，比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Dpet getEmpAndDpetByStepTwo(@Param(&quot;deptId&quot;)</span><br><span class="line">Integer deprId); 接口方法</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDpetByStepTwo&quot;</span> <span class="attr">resultType</span>=</span></span><br><span class="line"><span class="tag"><span class="string">&quot;Dept&quot;</span> <span class="attr">这里当然也可以配置resultMap</span>&gt;</span></span><br><span class="line">select * from t_dept where dept_id =#&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关联俩个sql，在之前的sql-asscociation里：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">select</span>=<span class="string">&quot;com.xxx.getEmpAndDpetByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">这里select要通过全类名.xxxMapper.方法名定位</span>； </span></span><br><span class="line"><span class="tag"><span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">这里的column写法的是列名</span>，<span class="attr">也就是第一个sql给下一个sql的条件</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><p>总之，整个过程就是，第一条sql：<code>select * from t_emp where emp_id = #&#123;empId&#125;</code>​查询出来了emp的数据，在association中配置，调用第二条sql，指定返回值为属性dept，同时把第一条sql的结果中的dept_id作为参数给到第二条sql；<code>select * from t_dept where dept_id =#&#123;deptId&#125; </code>​在resultMap里映射了他返回Dept类型，把Dept类型最后给到dept属性；<img src="https://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img001-1.0fe876b1.png" alt="./images">​</p><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>比如查询到Customer的时候，不一定会使用Order的List集合数据。如果Order的集合数据始终没有使用，那么这部分数据占用的内存就浪费了。对此，我们希望<strong>不一定会被用到的数据，能够在需要使用的时候再去查询</strong>。</p><p>例如：对Customer进行1000次查询中，其中只有15次会用到Order的集合数据，那么就在需要使用时才去查询能够<strong>大幅度节约内存空间</strong>。</p><p>延迟加载的概念：对于实体类关联的属性到需要使用时才查询。也叫懒加载。</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用settings对Mybatis全局进行设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启延迟加载功能：需要配置两个配置项 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1、将lazyLoadingEnabled设置为true，开启懒加载功能 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2、将aggressiveLazyLoading设置为false，关闭“积极的懒加载” --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在高版本中，则</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mybatis全局配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启延迟加载功能 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">ggressiveLazyLoading在高版本默认就为false；</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么在使用时，比如上面的emp和dept，如果我们查询了一个emp结果，但是在之后的的代码里没有对emp的dept这个属性操作，那么就只会执行第一条sql而不会执行第二条sql，反之，如果需要dept属性，则又会执行二条sql；总之就是先查询第一个sql本身，在需要内部某特殊属性时再调用第二条sql查询；</p><p>当然，也可以对某一条sql设置延迟加载而不使用全局配置，比如：<em>fatchType&#x3D;“eager&#x2F;lazy</em>”，在分布查询的连接association里使用这个属性来设置是否开启这组分布查询sql的延迟加载，默认遵循全局配置；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">fatchType</span>=<span class="string">“eager”</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">select</span>=<span class="string">&quot;com.xxx.getEmpAndDpetByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">这里select要通过全类名.xxxMapper.方法名定位</span>； </span></span><br><span class="line"><span class="tag"><span class="attr">column</span>=<span class="string">&quot;dept_id&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">这里的column写法的是列名</span>，<span class="attr">也就是第一个sql给下一个sql的条件</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><p>类似association；区别在于collection处理一对多的关系，和association内部关注ofType属性而不是javaType属性</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230117143919-rdte19w.png" alt="image">​</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230117144031-6qpej3a.png" alt="image">​</p><h3 id="分步"><a href="#分步" class="headerlink" title="分步"></a>分步</h3><p>第一个sql</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230117144819-shfc1r2.png" alt="image">​</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230117144924-lghb8sn.png" alt="image">​</p><p>第二个sql</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230117145240-czdo8hl.png" alt="image">​</p><p>组合</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230117145307-0f1e2n0.png" alt="image">​</p><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题。</p><h2 id="If和Where"><a href="#If和Where" class="headerlink" title="If和Where"></a>If和Where</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByCondition(Employee employee); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">    select emp_id,emp_name,emp_salary from t_emp</span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- where标签会自动去掉“标签体内前面多余的and/or” --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用if标签，让我们可以有选择的加入SQL语句的片段。这个SQL语句片段是否要加入整个SQL语句，就看if标签判断的结果是否为true --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在if标签的test属性中，可以访问实体类的属性，不可以访问数据库表的字段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 在if标签内部，需要访问接口的参数时还是正常写#&#123;&#125; --&gt;</span></span><br><span class="line">            or emp_name=#&#123;empName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;gt;</span> 2000&quot;</span>&gt;</span></span><br><span class="line">            or emp_salary&gt;#&#123;empSalary&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">         第一种情况：所有条件都满足 WHERE emp_name=? or emp_salary&gt;?</span></span><br><span class="line"><span class="comment">         第二种情况：部分条件满足 WHERE emp_salary&gt;?</span></span><br><span class="line"><span class="comment">         第三种情况：所有条件都不满足 没有where子句</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重点，若包含满足的条件，where标签会生成where关键字并且自动去掉标签体内前面多余的and&#x2F;or；</p><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><p>使用trim标签控制条件部分两端是否包含某些字符</p><ul><li>prefix属性：指定要动态添加的前缀</li><li>suffix属性：指定要动态添加的后缀</li><li>prefixOverrides属性：指定要动态去掉的前缀，使用“|”分隔有可能的多个值</li><li>suffixOverrides属性：指定要动态去掉的后缀，使用“|”分隔有可能的多个值</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByTrim(Employee employee) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByConditionByTrim&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">    select emp_id,emp_name,emp_age,emp_salary,emp_gender</span><br><span class="line">    from t_emp</span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- prefix属性指定要动态添加的前缀 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- suffix属性指定要动态添加的后缀 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- prefixOverrides属性指定要动态去掉的前缀，使用“|”分隔有可能的多个值 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- suffixOverrides属性指定要动态去掉的后缀，使用“|”分隔有可能的多个值 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当前例子用where标签实现更简洁，但是trim标签更灵活，可以用在任何有需要的地方 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and|or&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span></span><br><span class="line">            emp_name=#&#123;empName&#125; and</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;gt;</span> 3000&quot;</span>&gt;</span></span><br><span class="line">            emp_salary&gt;#&#123;empSalary&#125; and</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empAge <span class="symbol">&amp;lt;</span>= 20&quot;</span>&gt;</span></span><br><span class="line">            emp_age=#&#123;empAge&#125; or</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empGender==&#x27;male&#x27;&quot;</span>&gt;</span></span><br><span class="line">            emp_gender=#&#123;empGender&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="choose-x2F-when-x2F-otherwise"><a href="#choose-x2F-when-x2F-otherwise" class="headerlink" title="choose&#x2F;when&#x2F;otherwise"></a>choose&#x2F;when&#x2F;otherwise</h2><p>在多个分支条件中，仅执行一个。</p><ul><li>从上到下依次执行条件判断</li><li>遇到的第一个满足条件的分支会被采纳</li><li>被采纳分支后面的分支都将不被考虑</li><li>如果所有的when分支都不满足，那么就执行otherwise分支，类似于if-else；</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByChoose(Employee employee) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByConditionByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">    select emp_id,emp_name,emp_salary from t_emp</span><br><span class="line">    where</span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span>emp_name=#&#123;empName&#125;<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span>emp_salary <span class="symbol">&amp;lt;</span> 3000<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span>1=1<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     第一种情况：第一个when满足条件 where emp_name=?</span></span><br><span class="line"><span class="comment">     第二种情况：第二个when满足条件 where emp_salary &lt; 3000</span></span><br><span class="line"><span class="comment">     第三种情况：两个when都不满足 where 1=1 执行了otherwise</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>实际开发时，对一个实体类对象进行更新。往往不是更新所有字段，而是更新一部分字段。此时页面上的表单往往不会给不修改的字段提供表单项。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5232&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">年  龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userAge&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">性  别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userGender&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">坐  标：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userPosition&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot; /&gt;&lt;br/&gt;   --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 余  额：&lt;input type=&quot;text&quot; name=&quot;userBalance&quot; /&gt;&lt;br/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等  级：&lt;input type=&quot;text&quot; name=&quot;userGrade&quot; /&gt;&lt;br/&gt;  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例如上面的表单，如果服务器端接收表单时，使用的是User这个实体类，那么userName、userBalance、userGrade接收到的数据就是null。</p><p>如果不加判断，直接用User对象去更新数据库，在Mapper配置文件中又是每一个字段都更新，那就会把userName、userBalance、userGrade设置为null值，从而造成数据库表中对应数据被破坏。</p><p>此时需要我们在Mapper配置文件中，对update语句的set子句进行定制，此时就可以使用动态SQL的set标签。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- void updateEmployeeDynamic(Employee employee) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployeeDynamic&quot;</span>&gt;</span></span><br><span class="line">    update t_emp</span><br><span class="line">    <span class="comment">&lt;!-- set emp_name=#&#123;empName&#125;,emp_salary=#&#123;empSalary&#125; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用set标签动态管理set子句，并且动态去掉两端多余的逗号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span></span><br><span class="line">            emp_name=#&#123;empName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span></span><br><span class="line">            emp_salary=#&#123;empSalary&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where emp_id=#&#123;empId&#125;</span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">         第一种情况：所有条件都满足 SET emp_name=?, emp_salary=?</span></span><br><span class="line"><span class="comment">         第二种情况：部分条件满足 SET emp_salary=?</span></span><br><span class="line"><span class="comment">         第三种情况：所有条件都不满足 update t_emp where emp_id=?</span></span><br><span class="line"><span class="comment">            没有set子句的update语句会导致SQL语法错误</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    collection属性：要遍历的集合</span></span><br><span class="line"><span class="comment">    item属性：遍历集合的过程中能得到每一个具体对象，在item属性中设置一个名字，将来通过这个名字引用遍历出来的对象</span></span><br><span class="line"><span class="comment">    separator属性：指定当foreach标签的标签体重复拼接字符串时，各个标签体字符串之间的分隔符</span></span><br><span class="line"><span class="comment">    open属性：指定整个循环把字符串拼好后，字符串整体的前面要添加的字符串</span></span><br><span class="line"><span class="comment">    close属性：指定整个循环把字符串拼好后，字符串整体的后面要添加的字符串</span></span><br><span class="line"><span class="comment">    index属性：这里起一个名字，便于后面引用</span></span><br><span class="line"><span class="comment">        遍历List集合，这里能够得到List集合的索引值</span></span><br><span class="line"><span class="comment">        遍历Map集合，这里能够得到Map集合的key</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;empList&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;values&quot;</span> <span class="attr">index</span>=<span class="string">&quot;myIndex&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在foreach标签内部如果需要引用遍历得到的具体的一个对象，需要使用item属性声明的名称 --&gt;</span></span><br><span class="line">    (#&#123;emp.empName&#125;,#&#123;myIndex&#125;,#&#123;emp.empSalary&#125;,#&#123;emp.empGender&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230117172322-ohe9cgc.png" alt="image">​</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230117172657-ktvak5f.png" alt="image">​</p><h3 id="批量更新时需要注意"><a href="#批量更新时需要注意" class="headerlink" title="批量更新时需要注意"></a>批量更新时需要注意</h3><p>上面批量插入的例子本质上是一条SQL语句，而实现批量更新则需要多条SQL语句拼起来，用分号分开。也就是一次性发送多条SQL语句让数据库执行。此时需要在数据库连接信息的URL地址中设置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atguigu.dev.url=jdbc:mysql://192.168.198.100:3306/mybatis-example?allowMultiQueries=true</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- int updateEmployeeBatch(@Param(&quot;empList&quot;) List&lt;Employee&gt; empList) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployeeBatch&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;empList&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;;&quot;</span>&gt;</span></span><br><span class="line">        update t_emp set emp_name=#&#123;emp.empName&#125; where emp_id=#&#123;emp.empId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SQL标签"><a href="#SQL标签" class="headerlink" title="SQL标签"></a>SQL标签</h2><p>抽取重复的SQL片段</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用sql标签抽取重复出现的SQL片段 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;mySelectSql&quot;</span>&gt;</span></span><br><span class="line">        select emp_id,emp_name,emp_age,emp_salary,emp_gender from t_emp</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用include标签引用声明的SQL片段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;mySelectSql&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>使用</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230117173303-xdo3shv.png" alt="image">​</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><ul><li>一级缓存：SqlSession级别</li><li>二级缓存：SqlSessionFactory级别</li></ul><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>一级缓存失效的情况</p><ul><li>不是同一个SqlSession</li><li>同一个SqlSession但是查询条件发生了变化</li><li>同一个SqlSession两次查询期间执行了任何一次增删改操作</li><li>同一个SqlSession两次查询期间手动清空了缓存</li><li>同一个SqlSession两次查询期间提交了事务</li></ul><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查间的结果会被缓存；</p><p>此后，若再次执行相同的查询语句，结果就会从缓存中获取</p><p>二级缓存开启的条件：</p><ol><li>在核心配置文件中，设置全局配置属性cacheEnabled正”true”,默认为true,不需要设置</li><li>在映射文件中设置标签<cache/></li><li>二级缓存必须在SqlSession关闭或提交之后有效</li><li>查询的数据所转换的实体类类型必须实现<strong>序列化的接口</strong></li></ol><p>使二级缓存失效的情况：<br>两次查询之间执行了任意的增册改，会使一级和二级缓存同时失效</p><h2 id="二级缓存相关配置"><a href="#二级缓存相关配置" class="headerlink" title="二级缓存相关配置"></a>二级缓存相关配置</h2><p>在Mapper配置文件中添加的cache标签可以设置一些属性：</p><ul><li>eviction属性：缓存回收策略<br>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。<br>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。<br>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。<br>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。<br>默认的是 LRU。</li><li>flushInterval属性：刷新间隔，单位毫秒<br>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新</li><li>size属性：引用数目，正整数<br>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</li><li>readOnly属性：只读，true&#x2F;false<br>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。<br>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 false。</li></ul><h2 id="查询顺序"><a href="#查询顺序" class="headerlink" title="查询顺序"></a>查询顺序</h2><ol><li>二级缓存</li><li>一级缓存</li><li>数据库</li></ol><h2 id="第三方缓存EhCache"><a href="#第三方缓存EhCache" class="headerlink" title="*第三方缓存EhCache"></a>*第三方缓存EhCache</h2><ol><li><p>导入Maven依赖</p><table><thead><tr><th>jar包名称</th><th>作用</th></tr></thead><tbody><tr><td>mybatis-ehcache</td><td>Mybatis和EHCache的整合包</td></tr><tr><td>ehcache</td><td>EHCache核心包</td></tr><tr><td>slf4j-api</td><td>SLF4J日志门面包</td></tr><tr><td>logback-classic</td><td>支持SLF4J门面接口的一个具体实现</td></tr></tbody></table></li><li><p>创建EHCache配置文件</p><p> <img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230117230021-zg6c094.png" alt="image">​</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;../config/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 磁盘保存路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;D:\atguigu\ehcache&quot;</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsOnDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>指定缓存管理器的具体类型</p><p> 还是到查询操作所在的Mapper配置文件中，找到之前设置的cache标签：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>日志</p><p> 存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。</p><p> 门面：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>JCL（Jakarta Commons Logging）</td><td>陈旧</td></tr><tr><td>SLF4J（Simple Logging Facade for Java）★</td><td>适合</td></tr><tr><td>jboss-logging</td><td>特殊专业领域使用</td></tr></tbody></table><p> 实现：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>log4j★</td><td>最初版</td></tr><tr><td>JUL（java.util.logging）</td><td>JDK自带</td></tr><tr><td>log4j2</td><td>Apache收购log4j后全面重构，内部实现和log4j完全不同</td></tr><tr><td>logback★</td><td>优雅、强大</td></tr></tbody></table></li><li><p>logback配置文件</p><p> <img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230117230258-ozqas6d.png" alt="image"></p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定日志输出的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 日志输出的格式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- 根据特殊需求指定局部日志级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.crowd.mapper&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>EHCache配置文件说明</p><p> 当借助CacheManager.add(“缓存名称”)创建Cache时，EhCache便会采用<defalutCache/>指定的的管理策略</p><table><thead><tr><th>属性名</th><th>是否必须</th><th>作用</th></tr></thead><tbody><tr><td>maxElementsInMemory</td><td>是</td><td>在内存中缓存的element的最大数目</td></tr><tr><td>maxElementsOnDisk</td><td>是</td><td>在磁盘上缓存的element的最大数目，若是0表示无穷大</td></tr><tr><td>eternal</td><td>是</td><td>设定缓存的elements是否永远不过期。<br />如果为true，则缓存的数据始终有效，<br />如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断</td></tr><tr><td>overflowToDisk</td><td>是</td><td>设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上</td></tr><tr><td>timeToIdleSeconds</td><td>否</td><td>当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，<br />这些数据便会删除，默认值是0,也就是可闲置时间无穷大</td></tr><tr><td>timeToLiveSeconds</td><td>否</td><td>缓存element的有效生命期，默认是0.,也就是element存活时间无穷大</td></tr><tr><td>diskSpoolBufferSizeMB</td><td>否</td><td>DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区</td></tr><tr><td>diskPersistent</td><td>否</td><td>在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。</td></tr><tr><td>diskExpiryThreadIntervalSeconds</td><td>否</td><td>磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，<br />相应的线程会进行一次EhCache中数据的清理工作</td></tr><tr><td>memoryStoreEvictionPolicy</td><td>否</td><td>当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。<br />默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出）</td></tr></tbody></table></li></ol><h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h1><ul><li><p>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的。</p></li><li><p>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：</p><ul><li>Java实体类</li><li>Mapper接口</li><li>Mapper配置文件</li></ul></li></ul><h2 id="生成逆向工程"><a href="#生成逆向工程" class="headerlink" title="生成逆向工程"></a>生成逆向工程</h2><p>Maven配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 依赖MyBatis核心包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 构建过程中用到的插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 插件的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 逆向工程的核心依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MBG配置</p><p>文件名必须是：generatorConfig.xml</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230117231823-zeecj72.png" alt="image">​</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            targetRuntime: 执行生成的逆向工程的版本</span></span><br><span class="line"><span class="comment">                    MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span></span><br><span class="line"><span class="comment">                    MyBatis3: 生成带条件的CRUD（奢华尊享版）</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库的连接信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://192.168.198.100:3306/mybatis-example&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;atguigu&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- javaBean的生成策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.entity&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span>  <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Mapper接口的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span>  <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 逆向分析的表 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_emp&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Employee&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_customer&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Customer&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_order&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Order&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意<code>&lt;jdbcConnection&gt;</code>的修改和目标路径的配置 <code>&lt;javaModelGenerator targetPackage=&quot;com.atguigu.mybatis.entity&quot; targetProject=&quot;.\src\main\java&quot;&gt;</code></p><p>maven-执行MBG插件的generate目标<br>​<img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230117232950-3ahnqem.png" alt="image">​</p><h2 id="QBC查询"><a href="#QBC查询" class="headerlink" title="QBC查询"></a>QBC查询</h2><p>QBC查询最大的特点就是将SQL语句中的WHERE子句进行了组件化的封装，让我们可以通过调用Criteria对象的方法自由的拼装查询条件。</p><p>对于自动生成的条件查询，需要使用QBC查询去调用；</p><p>类似这样的方法，需要传入一个xxxExample的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dept&gt; <span class="title function_">selectByExample</span><span class="params">(DeptExample example)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByExample&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.DeptExample&quot;</span> &gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    WARNING - @mbggenerated</span></span><br><span class="line"><span class="comment">    This element is automatically generated by MyBatis Generator, do not modify.</span></span><br><span class="line"><span class="comment">    This element was generated on Tue Jan 17 23:29:02 CST 2023.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  select</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;distinct&quot;</span> &gt;</span></span><br><span class="line">    distinct</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">  from t_dept</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_parameter != null&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Example_Where_Clause&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;orderByClause != null&quot;</span> &gt;</span></span><br><span class="line">    order by $&#123;orderByClause&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>QBC查询例，也就是通过创建xxxExample的对象，通过这个对象再去创建Criteria对象，通过Criteria对象就可以给SQL语句添加条件；添加的条件andXxxxx可以一直追加；</p><p>那么对于or的连接， </p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230118114238-pcmyoy4.png" alt="image">​</p><p>也只需要再次掉用example对象，调用or方法后继续调用andXxx方法，即相当于xxx and xxx or xxx and xxx这样的形式；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建EmployeeExample对象</span></span><br><span class="line"><span class="type">EmployeeExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmployeeExample</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.通过example对象创建Criteria对象</span></span><br><span class="line">EmployeeExample.<span class="type">Criteria</span> <span class="variable">criteria01</span> <span class="operator">=</span> example.createCriteria();</span><br><span class="line">EmployeeExample.<span class="type">Criteria</span> <span class="variable">criteria02</span> <span class="operator">=</span> example.or();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.在Criteria对象中封装查询条件</span></span><br><span class="line">criteria01</span><br><span class="line">    .andEmpAgeBetween(<span class="number">9</span>, <span class="number">99</span>)</span><br><span class="line">    .andEmpNameLike(<span class="string">&quot;%o%&quot;</span>)</span><br><span class="line">    .andEmpGenderEqualTo(<span class="string">&quot;male&quot;</span>)</span><br><span class="line">    .andEmpSalaryGreaterThan(<span class="number">500.55</span>);</span><br><span class="line"></span><br><span class="line">criteria02</span><br><span class="line">        .andEmpAgeBetween(<span class="number">9</span>, <span class="number">99</span>)</span><br><span class="line">        .andEmpNameLike(<span class="string">&quot;%o%&quot;</span>)</span><br><span class="line">        .andEmpGenderEqualTo(<span class="string">&quot;male&quot;</span>)</span><br><span class="line">        .andEmpSalaryGreaterThan(<span class="number">500.55</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line"></span><br><span class="line"><span class="type">EmployeeMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(EmployeeMapper.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.基于Criteria对象进行查询</span></span><br><span class="line">List&lt;Employee&gt; employeeList = mapper.selectByExample(example);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Employee employee : employeeList) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;employee = &quot;</span> + employee);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">session.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终SQL的效果：</span></span><br><span class="line"><span class="comment">// WHERE ( emp_age between ? and ? and emp_name like ? and emp_gender = ? and emp_salary &gt; ? ) or( emp_age between ? and ? and emp_name like ? and emp_gender = ? and emp_salary &gt; ? )</span></span><br></pre></td></tr></table></figure><h1 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h1><p>limit index,pageSize</p><p>pageSize：每页显示的条数</p><p>pageNum：当前页的页码</p><p>index：当前页的第一条数据的索引，index&#x3D;(pageNum-1)*pageSize</p><p>‍</p><p>count：总记录数</p><p>totalPage：总页数</p><p>totalPage &#x3D; count &#x2F; pageSize;</p><p>解决最后一页的，数据不足一页情况：</p><p>if(count % pageSize !&#x3D; 0){</p><p>totalPage +&#x3D; 1;</p><p>}</p><p>‍</p><p>pageSize&#x3D;4，pageNum&#x3D;1，index&#x3D;0 limit 0,4</p><p>pageSize&#x3D;4，pageNum&#x3D;3，index&#x3D;8 limit 8,4</p><p>pageSize&#x3D;4，pageNum&#x3D;6，index&#x3D;20 limit 20,4</p><p>‍</p><p>首页 上一页 2 3 4 5 6 下一页 末页</p><h2 id="使用分页插件"><a href="#使用分页插件" class="headerlink" title="使用分页插件"></a>使用分页插件</h2><h3 id="添加依赖和添加插件"><a href="#添加依赖和添加插件" class="headerlink" title="添加依赖和添加插件"></a>添加依赖和添加插件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在MyBatis的核心配置文件中配置插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置分页插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>依附于查询功能</p><ol><li><p>在查询功能之前开启查询功能；</p><p> 使用<code>PageHelper.startPage(int pageNum, int pageSize)</code>开启分页功能</p><p> 其中</p><p> pageNum：当前页的页码</p><p> pageSize：每页显示的条数</p></li><li><p>在查询获取list集合之后：</p><p> 使用<code>PageInfo pageInfo = new PageInfo&lt;&gt;(List list, intnavigatePages)</code>获取分页相关数据</p><p> ist：分页之后的数据</p><p> navigatePages：导航分页的页码数</p></li></ol><p><code>PageHelper.startPage(int pageNum, int pageSize)</code>​方法会返回一个page对象，这个对象包含page信息和内容信息；</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230118125102-mpqgq4w.png" alt="image">​</p><p>PageInfo<T>,T是查询的对象，这个方法接收一个list对象(也就是查询的list)和导航分页个数；</p><p><img src="https://cdn.staticaly.com/gh/hakinanako/pic_bed@main/MyBatis/assets/image-20230118125326-kbmdrgg.png" alt="image">​</p><p>PageInfo内部的数据更多，如</p><p>PageInfo{</p><p>pageNum&#x3D;8, pageSize&#x3D;4, size&#x3D;2, startRow&#x3D;29, endRow&#x3D;30, total&#x3D;30, pages&#x3D;8,</p><p>list&#x3D;Page{count&#x3D;true, pageNum&#x3D;8, pageSize&#x3D;4, startRow&#x3D;28, endRow&#x3D;32, total&#x3D;30,</p><p>pages&#x3D;8, reasonable&#x3D;false, pageSizeZero&#x3D;false},</p><p>prePage&#x3D;7, nextPage&#x3D;0, isFirstPage&#x3D;false, isLastPage&#x3D;true, hasPreviousPage&#x3D;true,</p><p>hasNextPage&#x3D;false, navigatePages&#x3D;5, navigateFirstPage4, navigateLastPage8,</p><p>navigatepageNums&#x3D;[4, 5, 6, 7, 8]</p><p>}</p><p>pageNum：当前页的页码</p><p>pageSize：每页显示的条数</p><p>size：当前页显示的真实条数</p><p>total：总记录数</p><p>pages：总页数</p><p>prePage：上一页的页码</p><p>nextPage：下一页的页码</p><p>isFirstPage&#x2F;isLastPage：是否为第一页&#x2F;最后一页</p><p>hasPreviousPage&#x2F;hasNextPage：是否存在上一页&#x2F;下一页</p><p>navigatePages：导航分页的页码数</p><p>navigatepageNums：导航分页的页码，[1,2,3,4,5]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>欢迎光临</title>
      <link href="/2023/01/19/01/"/>
      <url>/2023/01/19/01/</url>
      
        <content type="html"><![CDATA[<h1 id="不知道写啥就随便写写"><a href="#不知道写啥就随便写写" class="headerlink" title="不知道写啥就随便写写"></a>不知道写啥就随便写写</h1>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
